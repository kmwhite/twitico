#!/usr/bin/env python 
# Copyright (c) 2011, Kristofer M White
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
#    1. Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
# 
#    2. Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY KRISTOFER M WHITE ''AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL KRISTOFER M WHITE OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and documentation are
# those of the authors and should not be interpreted as representing official
# policies, either expressed or implied, of Kristofer M White.

# Standard Library Imports
import ConfigParser
import os
import sys
import thread
import time

# Third-Party Imports
try:
    import pygtk
    pygtk.require("2.0")
except ImportError:
    print 'Import Failure: PyGTK Not Available'
    sys.exit(1)
except:
    pass

try:
    import gtk
    import gtk.glade
    import gobject
except:
    print 'Import Failure: GTK Not Availible'
    print 'Ensure gtk, gtk.glade, and gobject are available'
    sys.exit(2)

import pynotify
import twitter
import twitter_oauth

class Twitico(object):
    ''' Main class representing the Twitico icon '''

    def __init__(self):
        ''' Twitico initializer '''

        # The consumer_* values are used to identify Twitico as Twitico to
        # the twitter servers.
        self.consumer_key='V5dE3MyRBD0nQL3sAwvjLA'
        self.consumer_secret='Y1knhhIQvdGZ2VcwQyT0Fjx1DL3wLyFKADr0xNDg'

        # We need to ensure the config_file exists before we try loading
        # it. We do not want 
        config_file = os.path.expanduser('~/.twitico/config')
        if not os.path.exists(config_file):
            self.display_alert_dialog('Config Missing')
            self.write_config_file(config_file)

        # Read in config and create attr's related
        self.config = self.read_config_file(config_file)
        for name, value in self.config['account'].iteritems():
            setattr(self, name, value)

        # create Api instance
        self.api = twitter_oauth.Api(self.consumer_key, self.consumer_secret,
                                     self.oauth_token, self.oauth_token_secret)

        # unless the specific keys are in the config, get_oauth_obj
        get_oauth_obj = twitter_oauth.GetOauth(self.consumer_key,
                                               self.consumer_secret)

        self.icon = gtk.StatusIcon()
        self.icon.set_from_stock(gtk.STOCK_ABOUT)
        self.icon.set_visible(True)
        self.icon.connect("popup-menu", self.create_right_click_menu)
        self.icon.set_tooltip('Initializing... ')
        self.tlock = thread.allocate_lock()

        # last_id represents the id of the last rendered tweet. We note this
        # so that we can prevent ourselves from repeating tweets in the
        # timeline.
        self.last_id = 0

    def create_right_click_menu(self, icon, button, time):
        ''' create the twitico menu '''
        menu = gtk.Menu()

        compose = gtk.MenuItem("Compose")
        compose.connect("activate", self.tweet)
        menu.append(compose)

        quit = gtk.MenuItem("Quit")
        quit.connect("activate", gtk.main_quit)
        menu.append(quit)

        menu.show_all()

        menu.popup(None, None, gtk.status_icon_position_menu, button, time, icon)

    def write_config_file(self, config_file):
        ''' create the twitico config file and directory '''

        config_dir = os.path.dirname(config_file)

        if not os.path.exists(config_dir):
            os.mkdir(config_dir, 0700)
        with open(config_file, 'w') as cfgfile:
            # create GetOauth instance
            get_oauth_obj = twitter_oauth.GetOauth(self.consumer_key,
                                                   self.consumer_secret)

            # get oauth_token and oauth token secret
            d = get_oauth_obj.get_oauth()

            # generate config
            config = ConfigParser.ConfigParser()
            config.add_section('account')
            config.set('account', 'oauth_token', d['oauth_token'])
            config.set('account', 'oauth_token_secret', d['oauth_token_secret'])
            config.write(cfgfile)
            cfgfile.close()

    def read_config_file(self, config_file):
        ''' read in an existing twitico config file '''
        config = {}
        cfg_blob = ConfigParser.ConfigParser()
        cfg_blob.read(config_file)
        for section in cfg_blob.sections():
            config[section] = {}
            for option in cfg_blob.options(section):
                config[section][option] = cfg_blob.get(section, option)
        return config

    def extract_response(self, entry, dialog, response):
        dialog.response(response)

    def get_text_input(self, mask_input = False):
        # http://ardoris.wordpress.com/2008/07/05/pygtk-text-entry-dialog/
        #base this on a message dialog
        dialog = gtk.MessageDialog( None,
                     gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                     gtk.MESSAGE_QUESTION,
                     gtk.BUTTONS_OK,
                     None)
        dialog.set_markup("What's Happening...")
        #create the text input field
        entry = gtk.Entry()
        if mask_input:
            entry.set_visibility(False)
        #allow the user to press enter to do ok
        entry.connect("activate", self.extract_response, dialog, gtk.RESPONSE_OK)
        #create a horizontal box to pack the entry and a label
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Name:"), False, 5, 5)
        hbox.pack_end(entry)
        #some secondary text
        #dialog.format_secondary_markup("This will be used for <i>identification</i> purposes")
        #add it and show it
        dialog.vbox.pack_end(hbox, True, True, 0)
        dialog.show_all()
        #go go go
        dialog.run()
        text = entry.get_text()
        dialog.destroy()
        return text

    def display_alert_dialog(self, message, message_type = 'info'):
        ''' display alert dialog '''
        dialogs = {
                'info': gtk.MESSAGE_INFO,
                'error': gtk.MESSAGE_ERROR,
                'question': gtk.MESSAGE_QUESTION,
                'warn': gtk.MESSAGE_WARNING
                }
        md = gtk.MessageDialog(None, gtk.DIALOG_DESTROY_WITH_PARENT,
                               dialogs[message_type], gtk.BUTTONS_CLOSE,
                               message)
        md.run()
        md.destroy()

    def find_updates(self):
        ''' Find all updates in the users  '''
        while True:
            self.tlock.acquire()
            updates = self.api.get_friends_timeline() #since_id = self.last_id)
            update_time = time.strftime("%a %Y.%m.%d %T")
            tooltip = "{0} updates at {1}".format(len(updates), update_time)
            try:
                for update in updates:
                    self.notify(update.user.screen_name, update.text)
                    if self.last_id < update.id:
                        self.last_id = update.id
                self.icon.set_tooltip(tooltip)
            except twitter_oauth.TwitterError as (errno, strerror):
                self.critical(errno, strerror)
            self.tlock.release()
            time.sleep(600)

    def tweet(self, widget, message = "FooBarBaz"):
        ''' Create a new tweet '''
        try:
            status = self.api.post_update(self.get_text_input())
            print "{0} Posting status update: {1}".format('info', status)
        except twitter_oauth.TwitterError as (errno, strerror):
            self.notify(errno, strerror, None, pynotify.URGENCY_CRITICAL)

    def notify(self, subject, text, icon = None, urgency = pynotify.URGENCY_NORMAL):
        ''' Create Notifications

            Possible levels:
                pynotify.URGENCY_LOW
                pynotify.URGENCY_NORMAL
                pynotify.URGENCY_CRITICAL
        '''
        if pynotify.init('Twitico'):
            n = pynotify.Notification(subject, text)
            n.set_urgency(urgency)
            n.show()
        else:
            print "{0}: {1}".format(subject, text)



if __name__ == '__main__':

    gobject.threads_init()
    gtk.gdk.threads_init()
    tw = Twitico()
    t = thread.start_new_thread(tw.find_updates, ())
    gtk.main()
